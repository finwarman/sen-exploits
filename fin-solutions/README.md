# 7CCSMSEN: Security Engineering Coursework

## hacker username: _fin_

Finley Warman, 2021/22

----

## The Objective

Run `/usr/local/bin/l33t` after each escalation to advance levels.

## The Shellcode

For many of these solution, we inject a shellcode that calls execve on the `l33t` program in `/usr/local/bin`.

This shellcode is based on the example kindly provided by _Mohamed Abouhashem_ in his KEATS forum post:

- hxxps://keats.kcl.ac.uk/mod/forum/discuss.php?d=451004

The shellcode used is the following:
```\xeb\x15\x5b\x31\xc0\x88\x43\x13\x89\x5b\x14\x89\x43\x18\x8d\x4b\x14\x89\xc2\xb0\x0b\xcd\x80\xe8\xe6\xff\xff\xff/usr/local/bin/l33t```

## The Exploits

Levels 1-5 require no buffer overflow exploits, and consist primarily of carefully crafting
arguments and modifying local files outside of the program to achieve desired behaviour.

To Run, (in each `./level{x}` directory)

- **Level 1**:
    run `./exploit` (See ./level1/README)

    password: `grabthis`, set `$HOME` to be '/var/challenge/level1'.

- **Level 2**:
    run `./exploit` (See ./level2/README)

    Add '/usr/local/bin/l33t' to `script.sh` during program execution.

- **Level 3**:
    run `./exploit` (See ./level3/README)

    Uses relative paths to backtrack to '/usr/local/bin/l33t'.

- **Level 4**:
    run `./exploit` (See ./level4/README)

    Abuses the '-exec' flag of `find` on a dummy file, to run `l33t`.

- **Level 5**:

    run `./exploit` (Also see level5/README)

    This is a buffer overflow exploit, we overflow `buffer` of length 192 to write into `filename`,
    we write '/usr/bin/env/l33t' which gets executed and brings us to the next level.

- **Level 6**:

    run `./exploit`

    Level 6 requires providing an index with each character for the input. Using Python list comprehension,
    we can enumerate each value in the input to provide a consecutive offset.
    Through some investigation, we can see the the start of the array (e.g. writing A0), places a value 28 bytes before
    the return address. We craft the first part of our input to overwrite this return address, and the second part to
    place a shell-code in the buffer. The return address is overwritten to jump to the shell-code in the buffer.
    (The address used in this case is 0xffffda3c, or "\x3c\xda\xff\xff" in hex-encoded little-endian. It lands in the NOP sled of the shell-code provided in ./level6/exploit)

- **Level 7**:

    run `./exploit`

    Level 7 is solved with a buffer overflow exploit. We have a buffer 'result', of size 256, that is populated with
    three arguments from argv. For the first argument, we provide the shell-code, padded with a NOP sled (0x90), so
    that we have our shell-code in the buffer. Then, we provide some further padding in the second argument, and the
    start of the third. Finally, having overflow the buffer, we write our desired return address back to the NOP sled of our shell-code in the buffer which executes our shell-code instead of returning from main, bringing us to the next level.

- **Level 8**:

    Steps:
         - First, run './load_shellcode.bin' to load the shell-code into the environment, as the 'LEET' environment variable.
         - Then, run `./exploit`

    `./find_shellcode.bin` is used to locate the memory address of the 'LEET' environment variable, and was used to craft the input.
    For example, `LEET address: 0xbffffcd9`, which is `\d9\fc\ff\bf` in little-endian.

    Source code for `load_shellcode.c` and `find_shellcode.c` are in './level8/sources'

    Level 8 is solved using a format string exploit (utilising Write-4 primitives) - we can craft an input to write arbitrary data to memory.

    For this exploit, we will overwrite an address in the Global Offset Table, `.got`. Specifically, we target the function `fclose`. The address of this function in the GOT can be foud with: `objdump --dynamic-reloc /var/challenge/level8/8 | grep fclose`, e.g. `0x0804a010`.
    If we locate the pointer pointing to this address, and overwrite it with our shell-code address above, then when `fclose` is called then `l33t` is executed instead.

    We find the location of the address to overwrite in GDB with `find 0xbffff000, 0xbfffff00, 0x8048783`.

    The input string is crafted such that a pointer to each consecutive byte of the target memory address, `0xbffff330`, is found in memory. We then locate the use the `%hnn` format specifier to write 1 byte at a time to the target pointer, which we control with `%{increment}x` to manipulate the buffer offset (by controlling `n`, the number of bytes written so far) and `%{offset}$hhn` modify the byte values.

N.B.:

From now on, whenever `find_shellcode.bin` or `load_shellcode.bin` are mentioned, they can be compiled from source in `./level8/8/sources`, otherwise the binaries can be re-used as they are not specific to any exploit.

Level 9

---
---

```signature

@@@@@@@@    @@@     @@@  @@@
@@@@@@@@    @@@     @@@@ @@@
@@!         @@!     @@!@!@@@
!@!         !@!     !@!!@!@!
@!!!:!      !!@     @!@ !!@!
!!!!!:      !!!     !@!  !!!
!!:         !!:     !!:  !!!
:!:         :!:     :!:  !:!
 ::          ::      ::   ::
 :          :       ::    :   - fin

```
