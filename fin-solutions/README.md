# 7CCSMSEN: Security Engineering Coursework

## hacker username: _fin_

Finley Warman, 2021/22

----

## The Objective

Run `/usr/local/bin/l33t` after each escalation to advance levels.

## The Shellcode

For many of these solution, we inject a shellcode that calls execve on the `l33t` program in `/usr/local/bin`.

This shellcode is based on the example kindly provided by _Mohamed Abouhashem_ in his KEATS forum post:

- hxxps://keats.kcl.ac.uk/mod/forum/discuss.php?d=451004

The shellcode used is the following:
```\xeb\x15\x5b\x31\xc0\x88\x43\x13\x89\x5b\x14\x89\x43\x18\x8d\x4b\x14\x89\xc2\xb0\x0b\xcd\x80\xe8\xe6\xff\xff\xff/usr/local/bin/l33t```

## The Exploits

Levels 1-4 require no buffer overflow exploits, and consist primarily of carefully crafting
arguments and modifying local files outside of the program to achieve desired behaviour.

To Run, (in each `./level{x}` directory)

- **Level 1**:
    run `./exploit` (See ./level1/README)

    password: `grabthis`, set `$HOME` to be '/var/challenge/level1'.

- **Level 2**:
    run `./exploit` (See ./level2/README)

    Add '/usr/local/bin/l33t' to `script.sh` during program execution.

- **Level 3**:
    run `./exploit` (See ./level3/README)

    Uses relative paths to backtrack to '/usr/local/bin/l33t'.

- **Level 4**:
    run `./exploit` (See ./level4/README)

    Abuses the '-exec' flag of `find` on a dummy file, to run `l33t`.

- **Level 5**:

    run `./exploit` (Also see level5/README)

    This is a buffer overflow exploit, we overflow `buffer` of length 192 to write into `filename`,
    we write '/usr/bin/env/l33t' which gets executed and brings us to the next level.

- **Level 6**:

    run `./exploit`

    Level 6 requires providing an index with each character for the input. Using Python list comprehension,
    we can enumerate each value in the input to provide a consecutive offset.
    Through some investigation, we can see the the start of the array (e.g. writing A0), places a value 28 bytes before
    the return address. We craft the first part of our input to overwrite this return address, and the second part to
    place a shell-code in the buffer. The return address is overwritten to jump to the shell-code in the buffer.
    (The address used in this case is 0xffffda3c, or "\x3c\xda\xff\xff" in hex-encoded little-endian. It lands in the NOP sled of the shell-code provided in ./level6/exploit)

- **Level 7**:

    run `./exploit`

    Level 7 is solved with a buffer overflow exploit. We have a buffer 'result', of size 256, that is populated with
    three arguments from argv. For the first argument, we provide the shell-code, padded with a NOP sled (0x90), so
    that we have our shell-code in the buffer. Then, we provide some further padding in the second argument, and the
    start of the third. Finally, having overflow the buffer, we write our desired return address back to the NOP sled of our shell-code in the buffer which executes our shell-code instead of returning from main, bringing us to the next level.

- **Level 8**:

    Steps:
         - First, run './load_shellcode.bin' to load the shell-code into the environment, as the 'LEET' environment variable.
         - Then, run `./exploit`

    `./find_shellcode.bin` is used to locate the memory address of the 'LEET' environment variable, and was used to craft the input.
    For example, `LEET address: 0xbffffcd9`, which is `\d9\fc\ff\bf` in little-endian.

    Source code for `load_shellcode.c` and `find_shellcode.c` are in './level8/sources'

    Level 8 is solved using a format string exploit (utilising Write-4 primitives) - we can craft an input to write arbitrary data to memory.

    For this exploit, we will overwrite an address in the Global Offset Table, `.got`. Specifically, we target the function `fclose`. The address of this function in the GOT can be foud with: `objdump --dynamic-reloc /var/challenge/level8/8 | grep fclose`, e.g. `0x0804a010`.
    If we locate the pointer pointing to this address, and overwrite it with our shell-code address above, then when `fclose` is called then `l33t` is executed instead.

    We find the location of the address to overwrite in GDB with `find 0xbffff000, 0xbfffff00, 0x8048783`.

    The input string is crafted such that a pointer to each consecutive byte of the target memory address, `0xbffff330`, is found in memory. We then locate the use the `%hnn` format specifier to write 1 byte at a time to the target pointer, which we control with `%{increment}x` to manipulate the buffer offset (by controlling `n`, the number of bytes written so far) and `%{offset}$hhn` to modify the byte values.

### Note

    From now on, whenever `find_shellcode.bin`, `find_env`, or `load_shellcode.bin` are mentioned, they can be compiled from source in `./level8/8/sources`, otherwise the binaries can be re-used as they are not specific to any exploit.

- **Level 9**:
    Steps:
        - run `./exploit`

    Level 9 can be completed by writing to memory using the vulnerable 'mystrcat' function.

    Observations about the input:

  - Powers of 2 as the input radix let us provide an input that would usually be considered to exceed the max value. This avoids the message `overflow detected, argument too large`. This allows us to overflow the buffer.

  - We can write arbitrary bytes into the environment variable, `SEPARATOR`.

  Using the address of our shellcode in the environment, e.g. `0xbffffcd9`, we can overwrite the return address of main to our shellcode address, thus triggering `l33t` and advancing to the next level.
  In order to do this, we first overflow the buffer so that the address used by 'mystrcat' points to an environment variable of a known address, in this case the env var 'TARGET', set by modifying the SEPARATOR variable. Then, the data at the pointer we provided is written past the end of the buffer, overwriting main's return address. We fill 'TARGET' with the pointer to our shellcode env var, 'LEET' which gets executed instead of main returning.

  `find_env.bin` can be used to find address of environment vars, e.g. `../find_env LEET`

- **Level 10**:
    run `env -i ./exploit` (`env -i ./exploit` will also work)

    There is some randomisation in the address space, due to the `alloca(safe_random(8192))`,
    which will offset the addresses by up to 8192 on each new instance of the server running.
    To counter this, the `exploit` bash script will retry until the payload successfully triggers the exploit. With a padding/NOP sled of 2^17 (minus the length of the actual shellcode), this usually takes 1 or 2 attempts. Based off the addresses in the offset, the actual value is around 2^(17.1).

    The environment is cleared when running the server to reduce address uncertainty for the exploit. After the padding NOP sled, we place the shellcode we wish to execute. Then, we pad the rest of the buffer a return address inside of the NOP sled. This buffer overflow will overwrite the return address from `manage_tcp_client` with our injection vector within the buffer. Finally, a newline character is ended to the end of the input so that the server progresses in the function and exits the reading while loop (eventually stepping through to the return point).

    The addresses to target / overwrite can be found through GDB, or by compiling a modified version of the `10.c` source-code which prints the buffer addresses and indices. An address in the NOP sled can be approximated by adding a value greater than the size of the buffer (e.g. 80,000), to the address the buffer starts at.

---
---

```signature

@@@@@@@@    @@@     @@@  @@@
@@@@@@@@    @@@     @@@@ @@@
@@!         @@!     @@!@!@@@
!@!         !@!     !@!!@!@!
@!!!:!      !!@     @!@ !!@!
!!!!!:      !!!     !@!  !!!
!!:         !!:     !!:  !!!
:!:         :!:     :!:  !:!
 ::          ::      ::   ::
 :          :       ::    :   - fin

```
