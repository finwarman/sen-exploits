run `env -i ./exploit` (`env -i ./exploit` will also work)

There is some randomisation in the address space, due to the `alloca(safe_random(8192))`,
which will offset the addresses by up to 8192 on each new instance of the server running.
To counter this, the `exploit` bash script will retry until the payload successfully triggers the exploit. With a padding/NOP sled of 2^17 (minus the length of the actual shellcode), this usually takes 1 or 2 attempts. Based off the addresses in the offset, the actual value is around 2^(17.1).

The environment is cleared when running the server to reduce address uncertainty for the exploit. After the padding NOP sled, we place the shellcode we wish to execute. Then, we pad the rest of the buffer a return address inside of the NOP sled. This buffer overflow will overwrite the return address from `manage_tcp_client` with our injection vector within the buffer. Finally, a newline character is ended to the end of the input so that the server progresses in the function and exits the reading while loop (eventually stepping through to the return point).

The addresses to target / overwrite can be found through GDB, or by compiling a modified version of the `10.c` source-code which prints the buffer addresses and indices. An address in the NOP sled can be approximated by adding a value greater than the size of the buffer (e.g. 80,000), to the address the buffer starts at.
