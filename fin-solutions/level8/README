- First, run './load_shellcode.bin' to load the shell-code into the environment, as the 'LEET' environment variable.
- Then, run `./exploit`

`./find_env LEET` or `./find_shellcode.bin` can be used to locate the memory address of the 'LEET' environment variable which is then used to craft the input.
For example, `LEET address: 0xbffffcd9`, which is `\d9\fc\ff\bf` in little-endian.

Source code for `load_shellcode.c`, `find_shellcode.c`, and `find_env.c` are in './level8/sources'

Level 8 is solved using a format string exploit (utilising Write-4 primitives) - we can craft an input to write arbitrary data to memory.

For this exploit, we will overwrite an address in the Global Offset Table, `.got`. Specifically, we target the function `fclose`. The address of this function in the GOT can be foud with: `objdump --dynamic-reloc /var/challenge/level8/8 | grep fclose`, e.g. `0x0804a010`.
If we locate the pointer pointing to this address, and overwrite it with our shell-code address above, then when `fclose` is called then `l33t` is executed instead.

We find the location of the address to overwrite in GDB with `find 0xbffff000, 0xbfffff00, 0x8048783`.

The input string is crafted such that a pointer to each consecutive byte of the target memory address, `0xbffff330`, is found in memory. We then locate the use the `%hnn` format specifier to write 1 byte at a time to the target pointer, which we control with `%{increment}x` to manipulate the buffer offset (by controlling `n`, the number of bytes written so far) and `%{offset}$hhn` to modify the byte values.
